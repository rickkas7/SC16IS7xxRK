<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SC16IS7xxRK: SC16IS7xxPort Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SC16IS7xxRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">SC16IS7xxPort Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for an instance of a UART.  
 <a href="class_s_c16_i_s7xx_port.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_c16_i_s7xx_r_k_8h_source.html">SC16IS7xxRK.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SC16IS7xxPort:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_c16_i_s7xx_port.png" usemap="#SC16IS7xxPort_map" alt=""/>
  <map id="SC16IS7xxPort_map" name="SC16IS7xxPort_map">
<area href="class_s_c16_i_s7x0.html" title="Class for SC16IS740, SC16IS750, SC16IS760 single I2C or SPI UART." alt="SC16IS7x0" shape="rect" coords="0,112,96,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0da41548b94e0dd46e6a195a5882d631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c16_i_s7xx_port.html">SC16IS7xxPort</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a0da41548b94e0dd46e6a195a5882d631">withBufferedRead</a> (size_t bufferSize)</td></tr>
<tr class="memdesc:a0da41548b94e0dd46e6a195a5882d631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable buffered read mode.  <br /></td></tr>
<tr class="separator:a0da41548b94e0dd46e6a195a5882d631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdb59df04f45d64ddedd21cfd5e45e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c16_i_s7xx_port.html">SC16IS7xxPort</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a7fdb59df04f45d64ddedd21cfd5e45e1">withTransmissionControlLevels</a> (uint8_t haltLevel, uint8_t resumeLevel)</td></tr>
<tr class="memdesc:a7fdb59df04f45d64ddedd21cfd5e45e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the auto RTS hardware flow control levels. Call before <a class="el" href="class_s_c16_i_s7xx_port.html#a3b4b54cef48348d1683ce7535b77cb80" title="Set up the chip. You must do this before reading or writing.">begin()</a> to change levels.  <br /></td></tr>
<tr class="separator:a7fdb59df04f45d64ddedd21cfd5e45e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4b54cef48348d1683ce7535b77cb80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a3b4b54cef48348d1683ce7535b77cb80">begin</a> (int baudRate, uint32_t options=<a class="el" href="class_s_c16_i_s7xx_port.html#a03404012026681a9f767bdebdcb96f2d">OPTIONS_8N1</a>)</td></tr>
<tr class="memdesc:a3b4b54cef48348d1683ce7535b77cb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the chip. You must do this before reading or writing.  <br /></td></tr>
<tr class="separator:a3b4b54cef48348d1683ce7535b77cb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224ea28ee130adb87c456ccceb29619c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a224ea28ee130adb87c456ccceb29619c">blockOnOverrun</a> (bool value=true)</td></tr>
<tr class="memdesc:a224ea28ee130adb87c456ccceb29619c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines what should happen when calls to <a class="el" href="class_s_c16_i_s7xx_port.html#a4719e90f266d42fd3b2384cd48b56cb5" title="Write a single byte to the serial port.">write()</a>/print()/println()/printlnf() that would overrun the buffer.  <br /></td></tr>
<tr class="separator:a224ea28ee130adb87c456ccceb29619c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4921cf47f7fa13bc0dd33b8982d3345"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#af4921cf47f7fa13bc0dd33b8982d3345">available</a> ()</td></tr>
<tr class="memdesc:af4921cf47f7fa13bc0dd33b8982d3345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes available to read from the serial port.  <br /></td></tr>
<tr class="separator:af4921cf47f7fa13bc0dd33b8982d3345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8735ad6bc050deecf1eb6529f6c6589"><td class="memItemLeft" align="right" valign="top"><a id="ad8735ad6bc050deecf1eb6529f6c6589" name="ad8735ad6bc050deecf1eb6529f6c6589"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>availableForWrite</b> ()</td></tr>
<tr class="memdesc:ad8735ad6bc050deecf1eb6529f6c6589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes available to write into the TX FIFO. <br /></td></tr>
<tr class="separator:ad8735ad6bc050deecf1eb6529f6c6589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a07180cb8d331585882d22925fb223a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a4a07180cb8d331585882d22925fb223a">read</a> ()</td></tr>
<tr class="memdesc:a4a07180cb8d331585882d22925fb223a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte from the serial port.  <br /></td></tr>
<tr class="separator:a4a07180cb8d331585882d22925fb223a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1633d82c726ac4cbe21045b692d46c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a9c1633d82c726ac4cbe21045b692d46c">peek</a> ()</td></tr>
<tr class="memdesc:a9c1633d82c726ac4cbe21045b692d46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte from the serial port, but do not remove it so it can be read again.  <br /></td></tr>
<tr class="separator:a9c1633d82c726ac4cbe21045b692d46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30934d63e919d6a67a5f1ec1ad0ce93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#ab30934d63e919d6a67a5f1ec1ad0ce93">flush</a> ()</td></tr>
<tr class="memdesc:ab30934d63e919d6a67a5f1ec1ad0ce93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all serial data is sent.  <br /></td></tr>
<tr class="separator:ab30934d63e919d6a67a5f1ec1ad0ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4719e90f266d42fd3b2384cd48b56cb5"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a4719e90f266d42fd3b2384cd48b56cb5">write</a> (uint8_t c)</td></tr>
<tr class="memdesc:a4719e90f266d42fd3b2384cd48b56cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single byte to the serial port.  <br /></td></tr>
<tr class="separator:a4719e90f266d42fd3b2384cd48b56cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae318be9aa6f90aa930339b90bdec296c"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#ae318be9aa6f90aa930339b90bdec296c">write</a> (const uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:ae318be9aa6f90aa930339b90bdec296c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a multiple bytes to the serial port.  <br /></td></tr>
<tr class="separator:ae318be9aa6f90aa930339b90bdec296c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3794d3dee036e82ede83c9e244a7c41"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#af3794d3dee036e82ede83c9e244a7c41">read</a> (uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:af3794d3dee036e82ede83c9e244a7c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a multiple bytes to the serial port.  <br /></td></tr>
<tr class="separator:af3794d3dee036e82ede83c9e244a7c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a03404012026681a9f767bdebdcb96f2d"><td class="memItemLeft" align="right" valign="top"><a id="a03404012026681a9f767bdebdcb96f2d" name="a03404012026681a9f767bdebdcb96f2d"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_8N1</b> = 0b000011</td></tr>
<tr class="memdesc:a03404012026681a9f767bdebdcb96f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 data bits, no parity, 1 stop bit <br /></td></tr>
<tr class="separator:a03404012026681a9f767bdebdcb96f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0b5cd61edd6cfee63ee08456fbc72f"><td class="memItemLeft" align="right" valign="top"><a id="a8b0b5cd61edd6cfee63ee08456fbc72f" name="a8b0b5cd61edd6cfee63ee08456fbc72f"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_8E1</b> = 0b011011</td></tr>
<tr class="memdesc:a8b0b5cd61edd6cfee63ee08456fbc72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 data bits, even parity, 1 stop bit <br /></td></tr>
<tr class="separator:a8b0b5cd61edd6cfee63ee08456fbc72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb806b1981fbeb3a888165806d736183"><td class="memItemLeft" align="right" valign="top"><a id="afb806b1981fbeb3a888165806d736183" name="afb806b1981fbeb3a888165806d736183"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_8O1</b> = 0b001011</td></tr>
<tr class="memdesc:afb806b1981fbeb3a888165806d736183"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 data bits, odd parity, 1 stop bit <br /></td></tr>
<tr class="separator:afb806b1981fbeb3a888165806d736183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d3a5122cdb97adac4f857cd2a2ae13"><td class="memItemLeft" align="right" valign="top"><a id="ae3d3a5122cdb97adac4f857cd2a2ae13" name="ae3d3a5122cdb97adac4f857cd2a2ae13"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_8N2</b> = 0b000111</td></tr>
<tr class="memdesc:ae3d3a5122cdb97adac4f857cd2a2ae13"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 data bits, no parity, 2 stop bits <br /></td></tr>
<tr class="separator:ae3d3a5122cdb97adac4f857cd2a2ae13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2928c328a5c2095b189a6bf00b504d"><td class="memItemLeft" align="right" valign="top"><a id="acc2928c328a5c2095b189a6bf00b504d" name="acc2928c328a5c2095b189a6bf00b504d"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_8E2</b> = 0b011111</td></tr>
<tr class="memdesc:acc2928c328a5c2095b189a6bf00b504d"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 data bits, even parity, 2 stop bits <br /></td></tr>
<tr class="separator:acc2928c328a5c2095b189a6bf00b504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e50c104725385814c1dbfea37a829"><td class="memItemLeft" align="right" valign="top"><a id="ac32e50c104725385814c1dbfea37a829" name="ac32e50c104725385814c1dbfea37a829"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_8O2</b> = 0b001111</td></tr>
<tr class="memdesc:ac32e50c104725385814c1dbfea37a829"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 data bits, odd parity, 2 stop bits <br /></td></tr>
<tr class="separator:ac32e50c104725385814c1dbfea37a829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36472b91d9e5a102bfe57b82b51d9e54"><td class="memItemLeft" align="right" valign="top"><a id="a36472b91d9e5a102bfe57b82b51d9e54" name="a36472b91d9e5a102bfe57b82b51d9e54"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_7N1</b> = 0b000010</td></tr>
<tr class="memdesc:a36472b91d9e5a102bfe57b82b51d9e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">7 data bits, no parity, 1 stop bit <br /></td></tr>
<tr class="separator:a36472b91d9e5a102bfe57b82b51d9e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e4efa0de63a7eebd95db0589f6941e"><td class="memItemLeft" align="right" valign="top"><a id="a84e4efa0de63a7eebd95db0589f6941e" name="a84e4efa0de63a7eebd95db0589f6941e"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_7E1</b> = 0b011010</td></tr>
<tr class="memdesc:a84e4efa0de63a7eebd95db0589f6941e"><td class="mdescLeft">&#160;</td><td class="mdescRight">7 data bits, even parity, 1 stop bit <br /></td></tr>
<tr class="separator:a84e4efa0de63a7eebd95db0589f6941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8ae63ac092f75e6cdd2a47fb042694"><td class="memItemLeft" align="right" valign="top"><a id="a7c8ae63ac092f75e6cdd2a47fb042694" name="a7c8ae63ac092f75e6cdd2a47fb042694"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_7O1</b> = 0b001010</td></tr>
<tr class="memdesc:a7c8ae63ac092f75e6cdd2a47fb042694"><td class="mdescLeft">&#160;</td><td class="mdescRight">7 data bits, odd parity, 1 stop bit <br /></td></tr>
<tr class="separator:a7c8ae63ac092f75e6cdd2a47fb042694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb97f2b1bcd0528007a7d50697374b6d"><td class="memItemLeft" align="right" valign="top"><a id="adb97f2b1bcd0528007a7d50697374b6d" name="adb97f2b1bcd0528007a7d50697374b6d"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_7N2</b> = 0b000110</td></tr>
<tr class="memdesc:adb97f2b1bcd0528007a7d50697374b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">7 data bits, no parity, 2 stop bits <br /></td></tr>
<tr class="separator:adb97f2b1bcd0528007a7d50697374b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bb7d5884738ced6054437b2b6a10b9"><td class="memItemLeft" align="right" valign="top"><a id="a15bb7d5884738ced6054437b2b6a10b9" name="a15bb7d5884738ced6054437b2b6a10b9"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_7E2</b> = 0b011110</td></tr>
<tr class="memdesc:a15bb7d5884738ced6054437b2b6a10b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">7 data bits, even parity, 2 stop bits <br /></td></tr>
<tr class="separator:a15bb7d5884738ced6054437b2b6a10b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea773abae4a37d0b7b15abf03f71062d"><td class="memItemLeft" align="right" valign="top"><a id="aea773abae4a37d0b7b15abf03f71062d" name="aea773abae4a37d0b7b15abf03f71062d"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_7O2</b> = 0b001110</td></tr>
<tr class="memdesc:aea773abae4a37d0b7b15abf03f71062d"><td class="mdescLeft">&#160;</td><td class="mdescRight">7 data bits, odd parity, 2 stop bits <br /></td></tr>
<tr class="separator:aea773abae4a37d0b7b15abf03f71062d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6bed6dd55b99970501fd70453516e8"><td class="memItemLeft" align="right" valign="top"><a id="aff6bed6dd55b99970501fd70453516e8" name="aff6bed6dd55b99970501fd70453516e8"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_FLOW_CONTROL_NONE</b> = 0b00000000</td></tr>
<tr class="memdesc:aff6bed6dd55b99970501fd70453516e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">No hardware flow control (default) <br /></td></tr>
<tr class="separator:aff6bed6dd55b99970501fd70453516e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f5cb8b241dd5f038c5f78fa9662b29"><td class="memItemLeft" align="right" valign="top"><a id="ae6f5cb8b241dd5f038c5f78fa9662b29" name="ae6f5cb8b241dd5f038c5f78fa9662b29"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_FLOW_CONTROL_RTS</b> = 0b01000000</td></tr>
<tr class="memdesc:ae6f5cb8b241dd5f038c5f78fa9662b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTS flow control (/RTS output indicates this side can receive data) <br /></td></tr>
<tr class="separator:ae6f5cb8b241dd5f038c5f78fa9662b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ee469f2fedc2c6891d50db1574c752"><td class="memItemLeft" align="right" valign="top"><a id="ab7ee469f2fedc2c6891d50db1574c752" name="ab7ee469f2fedc2c6891d50db1574c752"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_FLOW_CONTROL_CTS</b> = 0b10000000</td></tr>
<tr class="memdesc:ab7ee469f2fedc2c6891d50db1574c752"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTS flow control (/CTS input indicates the other side can receive data) <br /></td></tr>
<tr class="separator:ab7ee469f2fedc2c6891d50db1574c752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0594df25f3509aa6f0788651fb247ab7"><td class="memItemLeft" align="right" valign="top"><a id="a0594df25f3509aa6f0788651fb247ab7" name="a0594df25f3509aa6f0788651fb247ab7"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>OPTIONS_FLOW_CONTROL_RTS_CTS</b> = 0b11000000</td></tr>
<tr class="memdesc:a0594df25f3509aa6f0788651fb247ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware flow control in both directions. <br /></td></tr>
<tr class="separator:a0594df25f3509aa6f0788651fb247ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a25f03be882cc8e94f6e09240098fd958"><td class="memItemLeft" align="right" valign="top"><a id="a25f03be882cc8e94f6e09240098fd958" name="a25f03be882cc8e94f6e09240098fd958"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SC16IS7xxPort</b> ()</td></tr>
<tr class="memdesc:a25f03be882cc8e94f6e09240098fd958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected constructor; you never construct one of these directly. <br /></td></tr>
<tr class="separator:a25f03be882cc8e94f6e09240098fd958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae447f302d2509268fdead84c0f1b3637"><td class="memItemLeft" align="right" valign="top"><a id="ae447f302d2509268fdead84c0f1b3637" name="ae447f302d2509268fdead84c0f1b3637"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~SC16IS7xxPort</b> ()</td></tr>
<tr class="memdesc:ae447f302d2509268fdead84c0f1b3637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor; you never delete one of these directly. <br /></td></tr>
<tr class="separator:ae447f302d2509268fdead84c0f1b3637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fef89520577cfe9b601b2538a649001"><td class="memItemLeft" align="right" valign="top"><a id="a6fef89520577cfe9b601b2538a649001" name="a6fef89520577cfe9b601b2538a649001"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SC16IS7xxPort</b> (const <a class="el" href="class_s_c16_i_s7xx_port.html">SC16IS7xxPort</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6fef89520577cfe9b601b2538a649001"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a6fef89520577cfe9b601b2538a649001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2716ba9a7a94bb4df63d04769c7ced92"><td class="memItemLeft" align="right" valign="top"><a id="a2716ba9a7a94bb4df63d04769c7ced92" name="a2716ba9a7a94bb4df63d04769c7ced92"></a>
<a class="el" href="class_s_c16_i_s7xx_port.html">SC16IS7xxPort</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_s_c16_i_s7xx_port.html">SC16IS7xxPort</a> &amp;)=delete</td></tr>
<tr class="memdesc:a2716ba9a7a94bb4df63d04769c7ced92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a2716ba9a7a94bb4df63d04769c7ced92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ba2406934be9f76060a4c2d1d15c44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a47ba2406934be9f76060a4c2d1d15c44">handleIIR</a> ()</td></tr>
<tr class="memdesc:a47ba2406934be9f76060a4c2d1d15c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle reading the IIR register and dispatching to the interrupt handler.  <br /></td></tr>
<tr class="separator:a47ba2406934be9f76060a4c2d1d15c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aeea5b5c13bb6bac3398df2f5fb42e43c"><td class="memItemLeft" align="right" valign="top"><a id="aeea5b5c13bb6bac3398df2f5fb42e43c" name="aeea5b5c13bb6bac3398df2f5fb42e43c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasPeek</b> = false</td></tr>
<tr class="memdesc:aeea5b5c13bb6bac3398df2f5fb42e43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">There is a byte from the last <a class="el" href="class_s_c16_i_s7xx_port.html#a9c1633d82c726ac4cbe21045b692d46c" title="Read a single byte from the serial port, but do not remove it so it can be read again.">peek()</a> available. <br /></td></tr>
<tr class="separator:aeea5b5c13bb6bac3398df2f5fb42e43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cdcc7b1404163abd34ca44d4e44d1d"><td class="memItemLeft" align="right" valign="top"><a id="a71cdcc7b1404163abd34ca44d4e44d1d" name="a71cdcc7b1404163abd34ca44d4e44d1d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>peekByte</b> = 0</td></tr>
<tr class="memdesc:a71cdcc7b1404163abd34ca44d4e44d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The byte that was read if hasPeek == true. <br /></td></tr>
<tr class="separator:a71cdcc7b1404163abd34ca44d4e44d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f46b17a8087d60d9dec84f8037ba06"><td class="memItemLeft" align="right" valign="top"><a id="a78f46b17a8087d60d9dec84f8037ba06" name="a78f46b17a8087d60d9dec84f8037ba06"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>writeBlocksWhenFull</b> = true</td></tr>
<tr class="memdesc:a78f46b17a8087d60d9dec84f8037ba06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The write call blocks until there's room to write to the buffer (true) or discards (false) <br /></td></tr>
<tr class="separator:a78f46b17a8087d60d9dec84f8037ba06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673e785ef068c1622f4b3c0114efcdba"><td class="memItemLeft" align="right" valign="top"><a id="a673e785ef068c1622f4b3c0114efcdba" name="a673e785ef068c1622f4b3c0114efcdba"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>channel</b> = 0</td></tr>
<tr class="memdesc:a673e785ef068c1622f4b3c0114efcdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chip channel number for this port (0 or 1) <br /></td></tr>
<tr class="separator:a673e785ef068c1622f4b3c0114efcdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d02621c5c09e7121318fd0a2c60d14e"><td class="memItemLeft" align="right" valign="top"><a id="a9d02621c5c09e7121318fd0a2c60d14e" name="a9d02621c5c09e7121318fd0a2c60d14e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>ier</b> = 0</td></tr>
<tr class="memdesc:a9d02621c5c09e7121318fd0a2c60d14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the IER register, set from <a class="el" href="class_s_c16_i_s7xx_port.html#a3b4b54cef48348d1683ce7535b77cb80" title="Set up the chip. You must do this before reading or writing.">begin()</a> <br /></td></tr>
<tr class="separator:a9d02621c5c09e7121318fd0a2c60d14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4330173af24b5591e91879f9a2305f13"><td class="memItemLeft" align="right" valign="top"><a id="a4330173af24b5591e91879f9a2305f13" name="a4330173af24b5591e91879f9a2305f13"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>lcr</b> = 0</td></tr>
<tr class="memdesc:a4330173af24b5591e91879f9a2305f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the LCR register, set from <a class="el" href="class_s_c16_i_s7xx_port.html#a3b4b54cef48348d1683ce7535b77cb80" title="Set up the chip. You must do this before reading or writing.">begin()</a> <br /></td></tr>
<tr class="separator:a4330173af24b5591e91879f9a2305f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d392e0e8dae6684fc8850e7bf5166cc"><td class="memItemLeft" align="right" valign="top"><a id="a2d392e0e8dae6684fc8850e7bf5166cc" name="a2d392e0e8dae6684fc8850e7bf5166cc"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>efr</b> = 0</td></tr>
<tr class="memdesc:a2d392e0e8dae6684fc8850e7bf5166cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the EFR register, set from <a class="el" href="class_s_c16_i_s7xx_port.html#a3b4b54cef48348d1683ce7535b77cb80" title="Set up the chip. You must do this before reading or writing.">begin()</a> <br /></td></tr>
<tr class="separator:a2d392e0e8dae6684fc8850e7bf5166cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f784e83fe6fa7c423dec4f6561d022e"><td class="memItemLeft" align="right" valign="top"><a id="a1f784e83fe6fa7c423dec4f6561d022e" name="a1f784e83fe6fa7c423dec4f6561d022e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>mcr</b> = 0</td></tr>
<tr class="memdesc:a1f784e83fe6fa7c423dec4f6561d022e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the MCR register, set from <a class="el" href="class_s_c16_i_s7xx_port.html#a3b4b54cef48348d1683ce7535b77cb80" title="Set up the chip. You must do this before reading or writing.">begin()</a> <br /></td></tr>
<tr class="separator:a1f784e83fe6fa7c423dec4f6561d022e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f8ea6016e842a620a480aa95fb5005"><td class="memItemLeft" align="right" valign="top"><a id="a88f8ea6016e842a620a480aa95fb5005" name="a88f8ea6016e842a620a480aa95fb5005"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>tcr</b> = (uint8_t)(30 &lt;&lt; 4 | 60)</td></tr>
<tr class="memdesc:a88f8ea6016e842a620a480aa95fb5005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default TCR value for hardware flow control (resume 30, halt 60) <br /></td></tr>
<tr class="separator:a88f8ea6016e842a620a480aa95fb5005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f522aa286ae24dc61193db5c9eb0221"><td class="memItemLeft" align="right" valign="top"><a id="a7f522aa286ae24dc61193db5c9eb0221" name="a7f522aa286ae24dc61193db5c9eb0221"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>tlr</b> = 0</td></tr>
<tr class="memdesc:a7f522aa286ae24dc61193db5c9eb0221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the TLR register, set from <a class="el" href="class_s_c16_i_s7xx_port.html#a3b4b54cef48348d1683ce7535b77cb80" title="Set up the chip. You must do this before reading or writing.">begin()</a> <br /></td></tr>
<tr class="separator:a7f522aa286ae24dc61193db5c9eb0221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd9d844d067076da68ca476193d9af1"><td class="memItemLeft" align="right" valign="top"><a id="acdd9d844d067076da68ca476193d9af1" name="acdd9d844d067076da68ca476193d9af1"></a>
<a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>interface</b> = nullptr</td></tr>
<tr class="memdesc:acdd9d844d067076da68ca476193d9af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface object for this chip. <br /></td></tr>
<tr class="separator:acdd9d844d067076da68ca476193d9af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f7e72a2fba91d1769f20fed9dd0143"><td class="memItemLeft" align="right" valign="top"><a id="aa7f7e72a2fba91d1769f20fed9dd0143" name="aa7f7e72a2fba91d1769f20fed9dd0143"></a>
<a class="el" href="class_s_c16_i_s7xx_buffer.html">SC16IS7xxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>readBuffer</b> = nullptr</td></tr>
<tr class="memdesc:aa7f7e72a2fba91d1769f20fed9dd0143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer object when using withReadBuffer. <br /></td></tr>
<tr class="separator:aa7f7e72a2fba91d1769f20fed9dd0143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dca9f4f4c8910a4ea6eb86f321ffefb"><td class="memItemLeft" align="right" valign="top"><a id="a7dca9f4f4c8910a4ea6eb86f321ffefb" name="a7dca9f4f4c8910a4ea6eb86f321ffefb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bufferedReadSize</b> = 0</td></tr>
<tr class="memdesc:a7dca9f4f4c8910a4ea6eb86f321ffefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of buffer for buffered read (0 = buffered read not enabled) <br /></td></tr>
<tr class="separator:a7dca9f4f4c8910a4ea6eb86f321ffefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b5f0d7226718f767157d28197af341"><td class="memItemLeft" align="right" valign="top"><a id="a68b5f0d7226718f767157d28197af341" name="a68b5f0d7226718f767157d28197af341"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>readFifoInterruptLevel</b> = 30</td></tr>
<tr class="memdesc:a68b5f0d7226718f767157d28197af341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt when FIFO has 30 characters (or timeout) <br /></td></tr>
<tr class="separator:a68b5f0d7226718f767157d28197af341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa228d7c84ace28c24ba0d199d802c6"><td class="memItemLeft" align="right" valign="top"><a id="abfa228d7c84ace28c24ba0d199d802c6" name="abfa228d7c84ace28c24ba0d199d802c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>readDataAvailable</b> = false</td></tr>
<tr class="memdesc:abfa228d7c84ace28c24ba0d199d802c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set from interruptRxTimeout and interruptRHR. <br /></td></tr>
<tr class="separator:abfa228d7c84ace28c24ba0d199d802c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66669f0233246790b047c87a0f41d22b"><td class="memItemLeft" align="right" valign="top"><a id="a66669f0233246790b047c87a0f41d22b" name="a66669f0233246790b047c87a0f41d22b"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>interruptLineStatus</b> = nullptr</td></tr>
<tr class="memdesc:a66669f0233246790b047c87a0f41d22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call for a line status interrupt. <br /></td></tr>
<tr class="separator:a66669f0233246790b047c87a0f41d22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe69c030035ff12fc29dd5bccc95b1f"><td class="memItemLeft" align="right" valign="top"><a id="afbe69c030035ff12fc29dd5bccc95b1f" name="afbe69c030035ff12fc29dd5bccc95b1f"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>interruptRxTimeout</b> = nullptr</td></tr>
<tr class="memdesc:afbe69c030035ff12fc29dd5bccc95b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call for stale data in RX FIFO. <br /></td></tr>
<tr class="separator:afbe69c030035ff12fc29dd5bccc95b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5cc0335bb3857dfdfaa290f01ec7d3"><td class="memItemLeft" align="right" valign="top"><a id="a7d5cc0335bb3857dfdfaa290f01ec7d3" name="a7d5cc0335bb3857dfdfaa290f01ec7d3"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>interruptRHR</b> = nullptr</td></tr>
<tr class="memdesc:a7d5cc0335bb3857dfdfaa290f01ec7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call for RHR FIFO above level. <br /></td></tr>
<tr class="separator:a7d5cc0335bb3857dfdfaa290f01ec7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a353609ca71b783518496bd3952c53a"><td class="memItemLeft" align="right" valign="top"><a id="a8a353609ca71b783518496bd3952c53a" name="a8a353609ca71b783518496bd3952c53a"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>interruptTHR</b> = nullptr</td></tr>
<tr class="memdesc:a8a353609ca71b783518496bd3952c53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call for THR FIFO below level. <br /></td></tr>
<tr class="separator:a8a353609ca71b783518496bd3952c53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7725720aa69f1a1d57f994bd364c37d"><td class="memItemLeft" align="right" valign="top"><a id="ad7725720aa69f1a1d57f994bd364c37d" name="ad7725720aa69f1a1d57f994bd364c37d"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>interruptModemStatus</b> = nullptr</td></tr>
<tr class="memdesc:ad7725720aa69f1a1d57f994bd364c37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call for change in modem input status. <br /></td></tr>
<tr class="separator:ad7725720aa69f1a1d57f994bd364c37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac779838008316312a3c24f9120606078"><td class="memItemLeft" align="right" valign="top"><a id="ac779838008316312a3c24f9120606078" name="ac779838008316312a3c24f9120606078"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>interruptIO</b> = nullptr</td></tr>
<tr class="memdesc:ac779838008316312a3c24f9120606078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call for GPIO interrupt. <br /></td></tr>
<tr class="separator:ac779838008316312a3c24f9120606078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25a9ff05d3ede64a7d639e04a481e61"><td class="memItemLeft" align="right" valign="top"><a id="aa25a9ff05d3ede64a7d639e04a481e61" name="aa25a9ff05d3ede64a7d639e04a481e61"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>interruptXoff</b> = nullptr</td></tr>
<tr class="memdesc:aa25a9ff05d3ede64a7d639e04a481e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call for a received Xoff with software flow control, or special bytes. <br /></td></tr>
<tr class="separator:aa25a9ff05d3ede64a7d639e04a481e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd652065ee32c5c8beea00032a95dd8"><td class="memItemLeft" align="right" valign="top"><a id="a9bd652065ee32c5c8beea00032a95dd8" name="a9bd652065ee32c5c8beea00032a95dd8"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>interruptCTS_RTS</b> = nullptr</td></tr>
<tr class="memdesc:a9bd652065ee32c5c8beea00032a95dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call for CTS or RTS transition low to high. <br /></td></tr>
<tr class="separator:a9bd652065ee32c5c8beea00032a95dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1c1b5df2114edfbcf40d072315999d2e"><td class="memItemLeft" align="right" valign="top"><a id="a1c1b5df2114edfbcf40d072315999d2e" name="a1c1b5df2114edfbcf40d072315999d2e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a1c1b5df2114edfbcf40d072315999d2e">SC16IS7x2</a></td></tr>
<tr class="memdesc:a1c1b5df2114edfbcf40d072315999d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_s_c16_i_s7x0.html" title="Class for SC16IS740, SC16IS750, SC16IS760 single I2C or SPI UART.">SC16IS7x0</a> derives from this, but the <a class="el" href="class_s_c16_i_s7x2.html" title="Class for SC16IS852 amd SC16IS862 dual SPI or I2C UART.">SC16IS7x2</a> has this ports as member variables. <br /></td></tr>
<tr class="separator:a1c1b5df2114edfbcf40d072315999d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ea1c78a64ff810a6704261b791cdb0"><td class="memItemLeft" align="right" valign="top"><a id="a85ea1c78a64ff810a6704261b791cdb0" name="a85ea1c78a64ff810a6704261b791cdb0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_port.html#a85ea1c78a64ff810a6704261b791cdb0">SC16IS7xxInterface</a></td></tr>
<tr class="memdesc:a85ea1c78a64ff810a6704261b791cdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the interface to call private members of this class, used to call <a class="el" href="class_s_c16_i_s7xx_port.html#a47ba2406934be9f76060a4c2d1d15c44" title="Handle reading the IIR register and dispatching to the interrupt handler.">handleIIR()</a> <br /></td></tr>
<tr class="separator:a85ea1c78a64ff810a6704261b791cdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for an instance of a UART. </p>
<p>There is one of these with the <a class="el" href="class_s_c16_i_s7x0.html" title="Class for SC16IS740, SC16IS750, SC16IS760 single I2C or SPI UART.">SC16IS7x0</a> and two with the <a class="el" href="class_s_c16_i_s7x2.html" title="Class for SC16IS852 amd SC16IS862 dual SPI or I2C UART.">SC16IS7x2</a>. You will not instantiate one of these directly. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af4921cf47f7fa13bc0dd33b8982d3345" name="af4921cf47f7fa13bc0dd33b8982d3345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4921cf47f7fa13bc0dd33b8982d3345">&#9670;&#160;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SC16IS7xxPort::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes available to read from the serial port. </p>
<p>This is a standard Arduino/Wiring method for Stream objects. </p>

</div>
</div>
<a id="a3b4b54cef48348d1683ce7535b77cb80" name="a3b4b54cef48348d1683ce7535b77cb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4b54cef48348d1683ce7535b77cb80">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SC16IS7xxPort::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="class_s_c16_i_s7xx_port.html#a03404012026681a9f767bdebdcb96f2d">OPTIONS_8N1</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up the chip. You must do this before reading or writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudRate</td><td>the baud rate (see below)</td></tr>
    <tr><td class="paramname">options</td><td>The number of data bits, parity, and stop bits</td></tr>
  </table>
  </dd>
</dl>
<p>You can call begin more than once if you want to change the baud rate. The FIFOs are cleared when you call begin.</p>
<p>Available baud rates depend on your oscillator, but with a 1.8432 MHz oscillator, the following are supported: 50, 75, 110, 134.5, 150, 300, 600, 1200, 1800, 2000, 2400, 3600, 4800, 7200, 9600, 19200, 38400, 57600, 115200</p>
<p>The valid options in standard number of bits; none=N, even=E, odd=O; number of stop bits format: OPTIONS_8N1, OPTIONS_8E1, OPTIONS_8O1 OPTIONS_8N2, OPTIONS_8E2, OPTIONS_8O2 OPTIONS_7N1, OPTIONS_7E1, OPTIONS_7O1 OPTIONS_7N2, OPTIONS_7E2, OPTIONS_7O2</p>
<p>Unlike the Device OS options, the SC16IS7xx OPTIONS_8N1 value is not 0! If you omit are enabling hardware flow control be sure to set it like <a class="el" href="class_s_c16_i_s7xx_port.html#a03404012026681a9f767bdebdcb96f2d" title="8 data bits, no parity, 1 stop bit">SC16IS7xxPort::OPTIONS_8N1</a> | <a class="el" href="class_s_c16_i_s7xx_port.html#a0594df25f3509aa6f0788651fb247ab7" title="Hardware flow control in both directions.">SC16IS7xxPort::OPTIONS_FLOW_CONTROL_RTS_CTS</a> If you leave off the OPTIONS_8N1 the output will be 5N1, not 8N1! </p>

</div>
</div>
<a id="a224ea28ee130adb87c456ccceb29619c" name="a224ea28ee130adb87c456ccceb29619c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224ea28ee130adb87c456ccceb29619c">&#9670;&#160;</a></span>blockOnOverrun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SC16IS7xxPort::blockOnOverrun </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines what should happen when calls to <a class="el" href="class_s_c16_i_s7xx_port.html#a4719e90f266d42fd3b2384cd48b56cb5" title="Write a single byte to the serial port.">write()</a>/print()/println()/printlnf() that would overrun the buffer. </p>
<p>blockOnOverrun(true) - this is the default setting. When there is no room in the buffer for the data to be written, the program waits/blocks until there is room. This avoids buffer overrun, where data that has not yet been sent over serial is overwritten by new data. Use this option for increased data integrity at the cost of slowing down realtime code execution when lots of serial data is sent at once.</p>
<p>blockOnOverrun(false) - when there is no room in the buffer for data to be written, the data is written anyway, causing the new data to replace the old data. This option is provided when performance is more important than data integrity. </p>

</div>
</div>
<a id="ab30934d63e919d6a67a5f1ec1ad0ce93" name="ab30934d63e919d6a67a5f1ec1ad0ce93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30934d63e919d6a67a5f1ec1ad0ce93">&#9670;&#160;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SC16IS7xxPort::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block until all serial data is sent. </p>
<p>This is a standard Arduino/Wiring method for Stream objects. </p>

</div>
</div>
<a id="a47ba2406934be9f76060a4c2d1d15c44" name="a47ba2406934be9f76060a4c2d1d15c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ba2406934be9f76060a4c2d1d15c44">&#9670;&#160;</a></span>handleIIR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SC16IS7xxPort::handleIIR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle reading the IIR register and dispatching to the interrupt handler. </p>
<p>This is used interally and you cannot call it. </p>

</div>
</div>
<a id="a9c1633d82c726ac4cbe21045b692d46c" name="a9c1633d82c726ac4cbe21045b692d46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1633d82c726ac4cbe21045b692d46c">&#9670;&#160;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SC16IS7xxPort::peek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single byte from the serial port, but do not remove it so it can be read again. </p>
<dl class="section return"><dt>Returns</dt><dd>a byte value 0 - 255 or -1 if no data is available.</dd></dl>
<p>This is a standard Arduino/Wiring method for Stream objects. </p>

</div>
</div>
<a id="a4a07180cb8d331585882d22925fb223a" name="a4a07180cb8d331585882d22925fb223a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a07180cb8d331585882d22925fb223a">&#9670;&#160;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SC16IS7xxPort::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single byte from the serial port. </p>
<dl class="section return"><dt>Returns</dt><dd>a byte value 0 - 255 or -1 if no data is available.</dd></dl>
<p>This is a standard Arduino/Wiring method for Stream objects. </p>

</div>
</div>
<a id="af3794d3dee036e82ede83c9e244a7c41" name="af3794d3dee036e82ede83c9e244a7c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3794d3dee036e82ede83c9e244a7c41">&#9670;&#160;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SC16IS7xxPort::read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a multiple bytes to the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read data into. It will not be null terminated.</td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of bytes to read (buffer size)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read or -1 if there are no bytes available to read.</dd></dl>
<p>This is faster than reading a single byte at time because up to 32 bytes of data can be sent or received in an I2C transaction, greatly reducing overhead. For SPI, 64 bytes can be written at a time. </p>

</div>
</div>
<a id="a0da41548b94e0dd46e6a195a5882d631" name="a0da41548b94e0dd46e6a195a5882d631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da41548b94e0dd46e6a195a5882d631">&#9670;&#160;</a></span>withBufferedRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c16_i_s7xx_port.html">SC16IS7xxPort</a> &amp; SC16IS7xxPort::withBufferedRead </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable buffered read mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferSize</td><td>Buffer size in bytes. The buffer is allocated on the heap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fdb59df04f45d64ddedd21cfd5e45e1" name="a7fdb59df04f45d64ddedd21cfd5e45e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdb59df04f45d64ddedd21cfd5e45e1">&#9670;&#160;</a></span>withTransmissionControlLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c16_i_s7xx_port.html">SC16IS7xxPort</a> &amp; SC16IS7xxPort::withTransmissionControlLevels </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>haltLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>resumeLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the auto RTS hardware flow control levels. Call before <a class="el" href="class_s_c16_i_s7xx_port.html#a3b4b54cef48348d1683ce7535b77cb80" title="Set up the chip. You must do this before reading or writing.">begin()</a> to change levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haltLevel</td><td>Number of characters in receive FIFO to halt transmission. Default: 60. </td></tr>
    <tr><td class="paramname">resumeLevel</td><td>Number of characters in receivee FIFO to resume transmission. Default: 30. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_s_c16_i_s7xx_port.html" title="Class for an instance of a UART.">SC16IS7xxPort</a>&amp; </dd></dl>

</div>
</div>
<a id="ae318be9aa6f90aa930339b90bdec296c" name="ae318be9aa6f90aa930339b90bdec296c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae318be9aa6f90aa930339b90bdec296c">&#9670;&#160;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SC16IS7xxPort::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a multiple bytes to the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to write. Can write binary or text data.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written.</dd></dl>
<p>This is faster than writing a single byte at time because up to 31 bytes of data can be sent or received in an I2C transaction, greatly reducing overhead. For SPI, 64 bytes can be written at a time. </p>

</div>
</div>
<a id="a4719e90f266d42fd3b2384cd48b56cb5" name="a4719e90f266d42fd3b2384cd48b56cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4719e90f266d42fd3b2384cd48b56cb5">&#9670;&#160;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SC16IS7xxPort::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a single byte to the serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The byte to write. Can write binary or text data.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a standard Arduino/Wiring method for Stream objects. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_s_c16_i_s7xx_r_k_8h_source.html">SC16IS7xxRK.h</a></li>
<li>src/SC16IS7xxRK.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
