<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SC16IS7xxRK: SC16IS7xxInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SC16IS7xxRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">SC16IS7xxInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Class that manages the SPI or I2C interface.  
 <a href="class_s_c16_i_s7xx_interface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_c16_i_s7xx_r_k_8h_source.html">SC16IS7xxRK.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SC16IS7xxInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_c16_i_s7xx_interface.png" usemap="#SC16IS7xxInterface_map" alt=""/>
  <map id="SC16IS7xxInterface_map" name="SC16IS7xxInterface_map">
<area href="class_s_c16_i_s7x0.html" title="Class for SC16IS740, SC16IS750, SC16IS760 single I2C or SPI UART." alt="SC16IS7x0" shape="rect" coords="0,56,123,80"/>
<area href="class_s_c16_i_s7x2.html" title="Class for SC16IS852 amd SC16IS862 dual SPI or I2C UART." alt="SC16IS7x2" shape="rect" coords="133,56,256,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a574613cfbf24c74bf9f85598843d38a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a574613cfbf24c74bf9f85598843d38a3">withI2C</a> (TwoWire *<a class="el" href="class_s_c16_i_s7xx_interface.html#aa627e723b96b82f7bd9c1d6e2e10bbce">wire</a>=&amp;Wire, uint8_t addr=0)</td></tr>
<tr class="memdesc:a574613cfbf24c74bf9f85598843d38a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chip is connected by I2C.  <br /></td></tr>
<tr class="separator:a574613cfbf24c74bf9f85598843d38a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7cdbe45c679802002e0e99c2fda566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a6d7cdbe45c679802002e0e99c2fda566">withSPI</a> (SPIClass *<a class="el" href="class_s_c16_i_s7xx_interface.html#a2fbb64a7f2c0cf847e49d24985fb3dcb">spi</a>, pin_t <a class="el" href="class_s_c16_i_s7xx_interface.html#a4881b76322d06dd563d751afdf35a313">csPin</a>, size_t speedMHz)</td></tr>
<tr class="memdesc:a6d7cdbe45c679802002e0e99c2fda566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chip is connected by SPI.  <br /></td></tr>
<tr class="separator:a6d7cdbe45c679802002e0e99c2fda566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12feb9381bf52541d2ed613d3ea91f44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a12feb9381bf52541d2ed613d3ea91f44">withOscillatorFrequency</a> (int freqHz)</td></tr>
<tr class="memdesc:a12feb9381bf52541d2ed613d3ea91f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the oscillator frequency for the chip.  <br /></td></tr>
<tr class="separator:a12feb9381bf52541d2ed613d3ea91f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302abc91c1f03e29cc3bd90fcaaddbbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a302abc91c1f03e29cc3bd90fcaaddbbc">withEnableGPIO</a> (bool enable=true)</td></tr>
<tr class="memdesc:a302abc91c1f03e29cc3bd90fcaaddbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable GPIO mode on SC16IS750, SC16IS760, SC16IS752, SC16IS762.  <br /></td></tr>
<tr class="separator:a302abc91c1f03e29cc3bd90fcaaddbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1d16a1d128fb558600b7bd0f63c859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#acc1d16a1d128fb558600b7bd0f63c859">withIRQ</a> (pin_t <a class="el" href="class_s_c16_i_s7xx_interface.html#a33465d1116d3f3f18a4d709a579e36be">irqPin</a>, PinMode mode=INPUT_PULLUP)</td></tr>
<tr class="memdesc:acc1d16a1d128fb558600b7bd0f63c859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pin used for IRQ (hardware interrupts). This is optional.  <br /></td></tr>
<tr class="separator:acc1d16a1d128fb558600b7bd0f63c859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d0ec757cb782d5592b366576e4be1b"><td class="memItemLeft" align="right" valign="top"><a id="a60d0ec757cb782d5592b366576e4be1b" name="a60d0ec757cb782d5592b366576e4be1b"></a>
<a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>softwareReset</b> ()</td></tr>
<tr class="memdesc:a60d0ec757cb782d5592b366576e4be1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a software reset of the device. <br /></td></tr>
<tr class="separator:a60d0ec757cb782d5592b366576e4be1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d186d2670e364ce5763ee86f6c87194"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a6d186d2670e364ce5763ee86f6c87194">powerOnCheck</a> ()</td></tr>
<tr class="memdesc:a6d186d2670e364ce5763ee86f6c87194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a check to see if the device is set to the expected power-on values.  <br /></td></tr>
<tr class="separator:a6d186d2670e364ce5763ee86f6c87194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd497ba333c107b6902902a090d9902"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a6bd497ba333c107b6902902a090d9902">readRegister</a> (uint8_t channel, uint8_t reg)</td></tr>
<tr class="memdesc:a6bd497ba333c107b6902902a090d9902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a register.  <br /></td></tr>
<tr class="separator:a6bd497ba333c107b6902902a090d9902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298db59f1ca271b430fbb37e082ecf0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a298db59f1ca271b430fbb37e082ecf0b">writeRegister</a> (uint8_t channel, uint8_t reg, uint8_t value)</td></tr>
<tr class="memdesc:a298db59f1ca271b430fbb37e082ecf0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a register.  <br /></td></tr>
<tr class="separator:a298db59f1ca271b430fbb37e082ecf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a941329d1ef27e7ae4bfa099a151d68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a1a941329d1ef27e7ae4bfa099a151d68">forEachPort</a> (std::function&lt; void(<a class="el" href="class_s_c16_i_s7xx_port.html">SC16IS7xxPort</a> *port)&gt; callback)=0</td></tr>
<tr class="memdesc:a1a941329d1ef27e7ae4bfa099a151d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a callback for each port on this chip.  <br /></td></tr>
<tr class="separator:a1a941329d1ef27e7ae4bfa099a151d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a455e4516630e963510840e548ae97701"><td class="memItemLeft" align="right" valign="top"><a id="a455e4516630e963510840e548ae97701" name="a455e4516630e963510840e548ae97701"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>RHR_THR_REG</b> = 0x00</td></tr>
<tr class="memdesc:a455e4516630e963510840e548ae97701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Holding Register (RHR) and Transmit Holding Register (THR) <br /></td></tr>
<tr class="separator:a455e4516630e963510840e548ae97701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc57483b34292948b482129b56e0522a"><td class="memItemLeft" align="right" valign="top"><a id="adc57483b34292948b482129b56e0522a" name="adc57483b34292948b482129b56e0522a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>IER_REG</b> = 0x01</td></tr>
<tr class="memdesc:adc57483b34292948b482129b56e0522a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Enable Register (IER) <br /></td></tr>
<tr class="separator:adc57483b34292948b482129b56e0522a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4915b020cec3dbb9c094ba97c460dd9f"><td class="memItemLeft" align="right" valign="top"><a id="a4915b020cec3dbb9c094ba97c460dd9f" name="a4915b020cec3dbb9c094ba97c460dd9f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>FCR_IIR_REG</b> = 0x02</td></tr>
<tr class="memdesc:a4915b020cec3dbb9c094ba97c460dd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Identification Register (IIR) and FIFO Control Register (FCR) <br /></td></tr>
<tr class="separator:a4915b020cec3dbb9c094ba97c460dd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a790e31229c12c3f884ba76e5a353"><td class="memItemLeft" align="right" valign="top"><a id="ac49a790e31229c12c3f884ba76e5a353" name="ac49a790e31229c12c3f884ba76e5a353"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>LCR_REG</b> = 0x03</td></tr>
<tr class="memdesc:ac49a790e31229c12c3f884ba76e5a353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line Control Register (LCR) <br /></td></tr>
<tr class="separator:ac49a790e31229c12c3f884ba76e5a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28f60735e2df2a398c445209a734468"><td class="memItemLeft" align="right" valign="top"><a id="ae28f60735e2df2a398c445209a734468" name="ae28f60735e2df2a398c445209a734468"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>MCR_REG</b> = 0x04</td></tr>
<tr class="memdesc:ae28f60735e2df2a398c445209a734468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modem Control Register (MCR) <br /></td></tr>
<tr class="separator:ae28f60735e2df2a398c445209a734468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06d4434b205318551a48df06963ea5e"><td class="memItemLeft" align="right" valign="top"><a id="ab06d4434b205318551a48df06963ea5e" name="ab06d4434b205318551a48df06963ea5e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>LSR_REG</b> = 0x05</td></tr>
<tr class="memdesc:ab06d4434b205318551a48df06963ea5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line Status Register (LSR) <br /></td></tr>
<tr class="separator:ab06d4434b205318551a48df06963ea5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4979e5eae8d12683eb16bdce6e8f290c"><td class="memItemLeft" align="right" valign="top"><a id="a4979e5eae8d12683eb16bdce6e8f290c" name="a4979e5eae8d12683eb16bdce6e8f290c"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>MSR_REG</b> = 0x06</td></tr>
<tr class="memdesc:a4979e5eae8d12683eb16bdce6e8f290c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modem Status Register (MSR) <br /></td></tr>
<tr class="separator:a4979e5eae8d12683eb16bdce6e8f290c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130579013a8dce687416834393738462"><td class="memItemLeft" align="right" valign="top"><a id="a130579013a8dce687416834393738462" name="a130579013a8dce687416834393738462"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>TCR_REG</b> = 0x06</td></tr>
<tr class="memdesc:a130579013a8dce687416834393738462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmission control register (TCR) when MCR[2] = 1 and EFR[4] = 1. <br /></td></tr>
<tr class="separator:a130579013a8dce687416834393738462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d120425372cc5cb031d54367bbe54"><td class="memItemLeft" align="right" valign="top"><a id="a8d3d120425372cc5cb031d54367bbe54" name="a8d3d120425372cc5cb031d54367bbe54"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>SPR_REG</b> = 0x07</td></tr>
<tr class="memdesc:a8d3d120425372cc5cb031d54367bbe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scratchpad Register (SPR) - if MCR[2] = 1 and EFR[4] = 1. <br /></td></tr>
<tr class="separator:a8d3d120425372cc5cb031d54367bbe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa442418825d53cf3c57d7ea89cd469ab"><td class="memItemLeft" align="right" valign="top"><a id="aa442418825d53cf3c57d7ea89cd469ab" name="aa442418825d53cf3c57d7ea89cd469ab"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>TLR_REG</b> = 0x07</td></tr>
<tr class="memdesc:aa442418825d53cf3c57d7ea89cd469ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmission level register (TLR) - if MCR[2] = 1 and EFR[4] = 1. <br /></td></tr>
<tr class="separator:aa442418825d53cf3c57d7ea89cd469ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33c89d2e276c1fef2400b15a3d0ac93"><td class="memItemLeft" align="right" valign="top"><a id="ab33c89d2e276c1fef2400b15a3d0ac93" name="ab33c89d2e276c1fef2400b15a3d0ac93"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>TXLVL_REG</b> = 0x08</td></tr>
<tr class="memdesc:ab33c89d2e276c1fef2400b15a3d0ac93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit FIFO Level register. <br /></td></tr>
<tr class="separator:ab33c89d2e276c1fef2400b15a3d0ac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84edfa3164cf15227ebfbbce4a6df6d9"><td class="memItemLeft" align="right" valign="top"><a id="a84edfa3164cf15227ebfbbce4a6df6d9" name="a84edfa3164cf15227ebfbbce4a6df6d9"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>RXLVL_REG</b> = 0x09</td></tr>
<tr class="memdesc:a84edfa3164cf15227ebfbbce4a6df6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive FIFO Level register. <br /></td></tr>
<tr class="separator:a84edfa3164cf15227ebfbbce4a6df6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758854ac6ce8592d8d8ae6884df30dac"><td class="memItemLeft" align="right" valign="top"><a id="a758854ac6ce8592d8d8ae6884df30dac" name="a758854ac6ce8592d8d8ae6884df30dac"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>IODIR_REG</b> = 0x0a</td></tr>
<tr class="memdesc:a758854ac6ce8592d8d8ae6884df30dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O pin Direction register. <br /></td></tr>
<tr class="separator:a758854ac6ce8592d8d8ae6884df30dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad028f334c58fca720534a800fc746a71"><td class="memItemLeft" align="right" valign="top"><a id="ad028f334c58fca720534a800fc746a71" name="ad028f334c58fca720534a800fc746a71"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>IOSTATE_REG</b> = 0x0b</td></tr>
<tr class="memdesc:ad028f334c58fca720534a800fc746a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O pins State register. <br /></td></tr>
<tr class="separator:ad028f334c58fca720534a800fc746a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bef1548d7b8d9f64b29d0ce2206b3a1"><td class="memItemLeft" align="right" valign="top"><a id="a2bef1548d7b8d9f64b29d0ce2206b3a1" name="a2bef1548d7b8d9f64b29d0ce2206b3a1"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>IOINTENA_REG</b> = 0x0c</td></tr>
<tr class="memdesc:a2bef1548d7b8d9f64b29d0ce2206b3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O Interrupt Enable register. <br /></td></tr>
<tr class="separator:a2bef1548d7b8d9f64b29d0ce2206b3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcd00b15df1e90d200185c193a2faff"><td class="memItemLeft" align="right" valign="top"><a id="a1fcd00b15df1e90d200185c193a2faff" name="a1fcd00b15df1e90d200185c193a2faff"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>IOCONTROL_REG</b> = 0x0e</td></tr>
<tr class="memdesc:a1fcd00b15df1e90d200185c193a2faff"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O pins Control register. <br /></td></tr>
<tr class="separator:a1fcd00b15df1e90d200185c193a2faff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baf0ebbe06cf6850c536d27a8fd4459"><td class="memItemLeft" align="right" valign="top"><a id="a2baf0ebbe06cf6850c536d27a8fd4459" name="a2baf0ebbe06cf6850c536d27a8fd4459"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>EFCR_REG</b> = 0x0f</td></tr>
<tr class="memdesc:a2baf0ebbe06cf6850c536d27a8fd4459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra Features Control Register. <br /></td></tr>
<tr class="separator:a2baf0ebbe06cf6850c536d27a8fd4459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3aaaf59c47ffe4c3ab14ddf7eaf021"><td class="memItemLeft" align="right" valign="top"><a id="afa3aaaf59c47ffe4c3ab14ddf7eaf021" name="afa3aaaf59c47ffe4c3ab14ddf7eaf021"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>LCR_DEFAULT</b> = 0x1D</td></tr>
<tr class="memdesc:afa3aaaf59c47ffe4c3ab14ddf7eaf021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power-on default value of LCR. <br /></td></tr>
<tr class="separator:afa3aaaf59c47ffe4c3ab14ddf7eaf021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac482443447da2cbd9e47488d2336ad45"><td class="memItemLeft" align="right" valign="top"><a id="ac482443447da2cbd9e47488d2336ad45" name="ac482443447da2cbd9e47488d2336ad45"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>LCR_SPECIAL_ENABLE_DIVISOR_LATCH</b> = 0x80</td></tr>
<tr class="memdesc:ac482443447da2cbd9e47488d2336ad45"><td class="mdescLeft">&#160;</td><td class="mdescRight">LCR bit to enable setting divisor. <br /></td></tr>
<tr class="separator:ac482443447da2cbd9e47488d2336ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4757f1a3f54da7dc1a096030e2feb6"><td class="memItemLeft" align="right" valign="top"><a id="add4757f1a3f54da7dc1a096030e2feb6" name="add4757f1a3f54da7dc1a096030e2feb6"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>LCR_ENABLE_ENHANCED_FEATURE_REG</b> = 0xbf</td></tr>
<tr class="memdesc:add4757f1a3f54da7dc1a096030e2feb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">LCR bit to enable enhanced features. <br /></td></tr>
<tr class="separator:add4757f1a3f54da7dc1a096030e2feb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7650cefe6ac940acdfb13e86d50943e3"><td class="memItemLeft" align="right" valign="top"><a id="a7650cefe6ac940acdfb13e86d50943e3" name="a7650cefe6ac940acdfb13e86d50943e3"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>DLL_REG</b> = 0x00</td></tr>
<tr class="memdesc:a7650cefe6ac940acdfb13e86d50943e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divisor Latch LSB (DLL) <br /></td></tr>
<tr class="separator:a7650cefe6ac940acdfb13e86d50943e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade13c36dbe2cce081385e404bc98a367"><td class="memItemLeft" align="right" valign="top"><a id="ade13c36dbe2cce081385e404bc98a367" name="ade13c36dbe2cce081385e404bc98a367"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>DLH_REG</b> = 0x01</td></tr>
<tr class="memdesc:ade13c36dbe2cce081385e404bc98a367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divisor Latch MSB (DLH) <br /></td></tr>
<tr class="separator:ade13c36dbe2cce081385e404bc98a367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b238030f39b04c6eb0cc00528a0cc9"><td class="memItemLeft" align="right" valign="top"><a id="a10b238030f39b04c6eb0cc00528a0cc9" name="a10b238030f39b04c6eb0cc00528a0cc9"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>EFR_REG</b> = 0x02</td></tr>
<tr class="memdesc:a10b238030f39b04c6eb0cc00528a0cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enhanced Features Register (EFR) <br /></td></tr>
<tr class="separator:a10b238030f39b04c6eb0cc00528a0cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5172ad907fc1b06e086b1c3c18da75ba"><td class="memItemLeft" align="right" valign="top"><a id="a5172ad907fc1b06e086b1c3c18da75ba" name="a5172ad907fc1b06e086b1c3c18da75ba"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>XON1_REG</b> = 0x04</td></tr>
<tr class="memdesc:a5172ad907fc1b06e086b1c3c18da75ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xon1 word. <br /></td></tr>
<tr class="separator:a5172ad907fc1b06e086b1c3c18da75ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1e1babea67eb21e0475288b02080f8"><td class="memItemLeft" align="right" valign="top"><a id="aea1e1babea67eb21e0475288b02080f8" name="aea1e1babea67eb21e0475288b02080f8"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>XON2_REG</b> = 0x05</td></tr>
<tr class="memdesc:aea1e1babea67eb21e0475288b02080f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xon2 word. <br /></td></tr>
<tr class="separator:aea1e1babea67eb21e0475288b02080f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe671eb24683ebebc4b2f6e8132e5abc"><td class="memItemLeft" align="right" valign="top"><a id="afe671eb24683ebebc4b2f6e8132e5abc" name="afe671eb24683ebebc4b2f6e8132e5abc"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>XOFF1_REG</b> = 0x06</td></tr>
<tr class="memdesc:afe671eb24683ebebc4b2f6e8132e5abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xoff1 word. <br /></td></tr>
<tr class="separator:afe671eb24683ebebc4b2f6e8132e5abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79665b9e7baab310722beeee032d63bf"><td class="memItemLeft" align="right" valign="top"><a id="a79665b9e7baab310722beeee032d63bf" name="a79665b9e7baab310722beeee032d63bf"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>XOFF2_REG</b> = 0x07</td></tr>
<tr class="memdesc:a79665b9e7baab310722beeee032d63bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xoff2 word. <br /></td></tr>
<tr class="separator:a79665b9e7baab310722beeee032d63bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7d289c73c331f4786494807c7fb398a8"><td class="memItemLeft" align="right" valign="top"><a id="a7d289c73c331f4786494807c7fb398a8" name="a7d289c73c331f4786494807c7fb398a8"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~SC16IS7xxInterface</b> ()</td></tr>
<tr class="memdesc:a7d289c73c331f4786494807c7fb398a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">You cannot instantiate this directly. <br /></td></tr>
<tr class="separator:a7d289c73c331f4786494807c7fb398a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9087f06e4feb80336002c9d80604b3f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a9087f06e4feb80336002c9d80604b3f2">SC16IS7xxInterface</a> (const <a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;)=delete</td></tr>
<tr class="memdesc:a9087f06e4feb80336002c9d80604b3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">You cannot delete this directly.  <br /></td></tr>
<tr class="separator:a9087f06e4feb80336002c9d80604b3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9a11b2ebec155707c75bd9f7d4e155"><td class="memItemLeft" align="right" valign="top"><a id="a1f9a11b2ebec155707c75bd9f7d4e155" name="a1f9a11b2ebec155707c75bd9f7d4e155"></a>
<a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;)=delete</td></tr>
<tr class="memdesc:a1f9a11b2ebec155707c75bd9f7d4e155"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a1f9a11b2ebec155707c75bd9f7d4e155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69e17a9dfc439a6a69553a201791654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#ad69e17a9dfc439a6a69553a201791654">beginTransaction</a> ()</td></tr>
<tr class="memdesc:ad69e17a9dfc439a6a69553a201791654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a SPI or I2C transaction.  <br /></td></tr>
<tr class="separator:ad69e17a9dfc439a6a69553a201791654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03350b57e267ffd052abe3568d07dcaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a03350b57e267ffd052abe3568d07dcaa">endTransaction</a> ()</td></tr>
<tr class="memdesc:a03350b57e267ffd052abe3568d07dcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a SPI or I2C transaction.  <br /></td></tr>
<tr class="separator:a03350b57e267ffd052abe3568d07dcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5db9b282a88f279e1651e76c52684e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a5d5db9b282a88f279e1651e76c52684e">readInternal</a> (uint8_t channel, uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:a5d5db9b282a88f279e1651e76c52684e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to read data.  <br /></td></tr>
<tr class="separator:a5d5db9b282a88f279e1651e76c52684e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85acd16652a58430558cd180856e47d9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a85acd16652a58430558cd180856e47d9">writeInternal</a> (uint8_t channel, const uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:a85acd16652a58430558cd180856e47d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to write data.  <br /></td></tr>
<tr class="separator:a85acd16652a58430558cd180856e47d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827556c0a5cdebc1de0b3fa7a1cb41c0"><td class="memItemLeft" align="right" valign="top"><a id="a827556c0a5cdebc1de0b3fa7a1cb41c0" name="a827556c0a5cdebc1de0b3fa7a1cb41c0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>readInternalMax</b> () const</td></tr>
<tr class="memdesc:a827556c0a5cdebc1de0b3fa7a1cb41c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bytes that can be read by readInternal. <br /></td></tr>
<tr class="separator:a827556c0a5cdebc1de0b3fa7a1cb41c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67795d81e12eb09fcaab85d1fe566929"><td class="memItemLeft" align="right" valign="top"><a id="a67795d81e12eb09fcaab85d1fe566929" name="a67795d81e12eb09fcaab85d1fe566929"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>writeInternalMax</b> () const</td></tr>
<tr class="memdesc:a67795d81e12eb09fcaab85d1fe566929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bytes that can be written by writeInternal. <br /></td></tr>
<tr class="separator:a67795d81e12eb09fcaab85d1fe566929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2191b9479259f3cc13435691c320bf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#ae2191b9479259f3cc13435691c320bf3">registerThreadFunction</a> (std::function&lt; void()&gt; fn)</td></tr>
<tr class="memdesc:ae2191b9479259f3cc13435691c320bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new function to be called from the worker thread.  <br /></td></tr>
<tr class="separator:ae2191b9479259f3cc13435691c320bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c46596468ffaf109245c81c393d7916"><td class="memItemLeft" align="right" valign="top"><a id="a9c46596468ffaf109245c81c393d7916" name="a9c46596468ffaf109245c81c393d7916"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>threadFunction</b> ()</td></tr>
<tr class="memdesc:a9c46596468ffaf109245c81c393d7916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread function called from FreeRTOS. Never returns! <br /></td></tr>
<tr class="separator:a9c46596468ffaf109245c81c393d7916"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a9c81687959de17db3a9c5647622dafe1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#a9c81687959de17db3a9c5647622dafe1">threadFunctionStatic</a> (void *param)</td></tr>
<tr class="memdesc:a9c81687959de17db3a9c5647622dafe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static thread function, called from FreeRTOS.  <br /></td></tr>
<tr class="separator:a9c81687959de17db3a9c5647622dafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa627e723b96b82f7bd9c1d6e2e10bbce"><td class="memItemLeft" align="right" valign="top"><a id="aa627e723b96b82f7bd9c1d6e2e10bbce" name="aa627e723b96b82f7bd9c1d6e2e10bbce"></a>
TwoWire *&#160;</td><td class="memItemRight" valign="bottom"><b>wire</b> = nullptr</td></tr>
<tr class="memdesc:aa627e723b96b82f7bd9c1d6e2e10bbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using I2C, the Wire object, typically Wire, but could be Wire1. <br /></td></tr>
<tr class="separator:aa627e723b96b82f7bd9c1d6e2e10bbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2585c95dfb1551bbbef5297837085117"><td class="memItemLeft" align="right" valign="top"><a id="a2585c95dfb1551bbbef5297837085117" name="a2585c95dfb1551bbbef5297837085117"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>i2cAddr</b> = 0</td></tr>
<tr class="memdesc:a2585c95dfb1551bbbef5297837085117"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using I2C, the I2C address of the SC16IS7xx chip. <br /></td></tr>
<tr class="separator:a2585c95dfb1551bbbef5297837085117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbb64a7f2c0cf847e49d24985fb3dcb"><td class="memItemLeft" align="right" valign="top"><a id="a2fbb64a7f2c0cf847e49d24985fb3dcb" name="a2fbb64a7f2c0cf847e49d24985fb3dcb"></a>
SPIClass *&#160;</td><td class="memItemRight" valign="bottom"><b>spi</b> = nullptr</td></tr>
<tr class="memdesc:a2fbb64a7f2c0cf847e49d24985fb3dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using SPI, the SPI object (typically SPI or SPI1). <br /></td></tr>
<tr class="separator:a2fbb64a7f2c0cf847e49d24985fb3dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4881b76322d06dd563d751afdf35a313"><td class="memItemLeft" align="right" valign="top"><a id="a4881b76322d06dd563d751afdf35a313" name="a4881b76322d06dd563d751afdf35a313"></a>
pin_t&#160;</td><td class="memItemRight" valign="bottom"><b>csPin</b> = PIN_INVALID</td></tr>
<tr class="memdesc:a4881b76322d06dd563d751afdf35a313"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using SPI, the CS pin (required for SPI) <br /></td></tr>
<tr class="separator:a4881b76322d06dd563d751afdf35a313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33465d1116d3f3f18a4d709a579e36be"><td class="memItemLeft" align="right" valign="top"><a id="a33465d1116d3f3f18a4d709a579e36be" name="a33465d1116d3f3f18a4d709a579e36be"></a>
pin_t&#160;</td><td class="memItemRight" valign="bottom"><b>irqPin</b> = PIN_INVALID</td></tr>
<tr class="memdesc:a33465d1116d3f3f18a4d709a579e36be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware IRQ from SC16IS7xx, optional. <br /></td></tr>
<tr class="separator:a33465d1116d3f3f18a4d709a579e36be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764ffe044a76109fc009d77ab132cb60"><td class="memItemLeft" align="right" valign="top"><a id="a764ffe044a76109fc009d77ab132cb60" name="a764ffe044a76109fc009d77ab132cb60"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>irqFifoLevel</b> = 30</td></tr>
<tr class="memdesc:a764ffe044a76109fc009d77ab132cb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes to trigger IRQ. <br /></td></tr>
<tr class="separator:a764ffe044a76109fc009d77ab132cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc875d19c669c76f6855d9e455c6f24"><td class="memItemLeft" align="right" valign="top"><a id="a3cc875d19c669c76f6855d9e455c6f24" name="a3cc875d19c669c76f6855d9e455c6f24"></a>
SPISettings&#160;</td><td class="memItemRight" valign="bottom"><b>spiSettings</b></td></tr>
<tr class="memdesc:a3cc875d19c669c76f6855d9e455c6f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using SPI, the SPISettings (bit rate, bit order, mode). <br /></td></tr>
<tr class="separator:a3cc875d19c669c76f6855d9e455c6f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76e2daecfeb224d3e915dff561a01eb"><td class="memItemLeft" align="right" valign="top"><a id="ac76e2daecfeb224d3e915dff561a01eb" name="ac76e2daecfeb224d3e915dff561a01eb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>enableGPIO</b></td></tr>
<tr class="memdesc:ac76e2daecfeb224d3e915dff561a01eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable GPIO mode. <br /></td></tr>
<tr class="separator:ac76e2daecfeb224d3e915dff561a01eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcae20a95e1713fee35c9768031ed2a0"><td class="memItemLeft" align="right" valign="top"><a id="adcae20a95e1713fee35c9768031ed2a0" name="adcae20a95e1713fee35c9768031ed2a0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>oscillatorFreqHz</b> = 1843200</td></tr>
<tr class="memdesc:adcae20a95e1713fee35c9768031ed2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator frequency. Default is 1.8432 MHz, can also be 3072000 (3.072 MHz). <br /></td></tr>
<tr class="separator:adcae20a95e1713fee35c9768031ed2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40379945ae9e8acbbfb812ac0fd2485e"><td class="memItemLeft" align="right" valign="top"><a id="a40379945ae9e8acbbfb812ac0fd2485e" name="a40379945ae9e8acbbfb812ac0fd2485e"></a>
Thread *&#160;</td><td class="memItemRight" valign="bottom"><b>workerThread</b> = nullptr</td></tr>
<tr class="memdesc:a40379945ae9e8acbbfb812ac0fd2485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread, created if <a class="el" href="class_s_c16_i_s7xx_interface.html#ae2191b9479259f3cc13435691c320bf3" title="Adds a new function to be called from the worker thread.">registerThreadFunction()</a> is called. <br /></td></tr>
<tr class="separator:a40379945ae9e8acbbfb812ac0fd2485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567009d7d5ccfaf519a5f982b85fff99"><td class="memItemLeft" align="right" valign="top"><a id="a567009d7d5ccfaf519a5f982b85fff99" name="a567009d7d5ccfaf519a5f982b85fff99"></a>
std::vector&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>threadFunctions</b></td></tr>
<tr class="memdesc:a567009d7d5ccfaf519a5f982b85fff99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to call from the worker thread, added using <a class="el" href="class_s_c16_i_s7xx_interface.html#ae2191b9479259f3cc13435691c320bf3" title="Adds a new function to be called from the worker thread.">registerThreadFunction()</a> <br /></td></tr>
<tr class="separator:a567009d7d5ccfaf519a5f982b85fff99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adb0c805a4d71e0f5be17ccd28ff121cc"><td class="memItemLeft" align="right" valign="top"><a id="adb0c805a4d71e0f5be17ccd28ff121cc" name="adb0c805a4d71e0f5be17ccd28ff121cc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_interface.html#adb0c805a4d71e0f5be17ccd28ff121cc">SC16IS7xxPort</a></td></tr>
<tr class="memdesc:adb0c805a4d71e0f5be17ccd28ff121cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port object calls the interface object and uses the register contents. <br /></td></tr>
<tr class="separator:adb0c805a4d71e0f5be17ccd28ff121cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that manages the SPI or I2C interface. </p>
<p>You will not instantiate one of these directly. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9087f06e4feb80336002c9d80604b3f2" name="a9087f06e4feb80336002c9d80604b3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9087f06e4feb80336002c9d80604b3f2">&#9670;&#160;</a></span>SC16IS7xxInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SC16IS7xxInterface::SC16IS7xxInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>You cannot delete this directly. </p>
<p>This class is not copyable </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad69e17a9dfc439a6a69553a201791654" name="ad69e17a9dfc439a6a69553a201791654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69e17a9dfc439a6a69553a201791654">&#9670;&#160;</a></span>beginTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SC16IS7xxInterface::beginTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins a SPI or I2C transaction. </p>
<p>A transaction is a group of related calls. Within the transaction other devices are prohibited from accessing the bus, but thread swapping is still enabled. </p>

</div>
</div>
<a id="a03350b57e267ffd052abe3568d07dcaa" name="a03350b57e267ffd052abe3568d07dcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03350b57e267ffd052abe3568d07dcaa">&#9670;&#160;</a></span>endTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SC16IS7xxInterface::endTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a SPI or I2C transaction. </p>
<p>A transaction is a group of related calls. Within the transaction other devices are prohibited from accessing the bus, but thread swapping is still enabled. </p>

</div>
</div>
<a id="a1a941329d1ef27e7ae4bfa099a151d68" name="a1a941329d1ef27e7ae4bfa099a151d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a941329d1ef27e7ae4bfa099a151d68">&#9670;&#160;</a></span>forEachPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SC16IS7xxInterface::forEachPort </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="class_s_c16_i_s7xx_port.html">SC16IS7xxPort</a> *port)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls a callback for each port on this chip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_s_c16_i_s7x0.html#a5440bc4085b7de3840e1f2ae12618dc4">SC16IS7x0</a>, and <a class="el" href="class_s_c16_i_s7x2.html#addb59e891a41078ea7b1dd414146da82">SC16IS7x2</a>.</p>

</div>
</div>
<a id="a6d186d2670e364ce5763ee86f6c87194" name="a6d186d2670e364ce5763ee86f6c87194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d186d2670e364ce5763ee86f6c87194">&#9670;&#160;</a></span>powerOnCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SC16IS7xxInterface::powerOnCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a check to see if the device is set to the expected power-on values. </p>

</div>
</div>
<a id="a5d5db9b282a88f279e1651e76c52684e" name="a5d5db9b282a88f279e1651e76c52684e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5db9b282a88f279e1651e76c52684e">&#9670;&#160;</a></span>readInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SC16IS7xxInterface::readInternal </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to read data. </p>
<p>It can only read 32 bytes at a time, the maximum that will fit in a 32 byte I2C transaction with the register address in the first byte. </p>

</div>
</div>
<a id="a6bd497ba333c107b6902902a090d9902" name="a6bd497ba333c107b6902902a090d9902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd497ba333c107b6902902a090d9902">&#9670;&#160;</a></span>readRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SC16IS7xxInterface::readRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel (0-3).</td></tr>
    <tr><td class="paramname">reg</td><td>The register number to read. Note that this should be the register 0 - 16, before shifting for channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2191b9479259f3cc13435691c320bf3" name="ae2191b9479259f3cc13435691c320bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2191b9479259f3cc13435691c320bf3">&#9670;&#160;</a></span>registerThreadFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SC16IS7xxInterface::registerThreadFunction </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new function to be called from the worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The function or lambda to call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c81687959de17db3a9c5647622dafe1" name="a9c81687959de17db3a9c5647622dafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c81687959de17db3a9c5647622dafe1">&#9670;&#160;</a></span>threadFunctionStatic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SC16IS7xxInterface::threadFunctionStatic </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static thread function, called from FreeRTOS. </p>
<p>Note: param must be a pointer to this. threadFunction is called from this function. Never returns! </p>

</div>
</div>
<a id="a302abc91c1f03e29cc3bd90fcaaddbbc" name="a302abc91c1f03e29cc3bd90fcaaddbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302abc91c1f03e29cc3bd90fcaaddbbc">&#9670;&#160;</a></span>withEnableGPIO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp; SC16IS7xxInterface::withEnableGPIO </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable GPIO mode on SC16IS750, SC16IS760, SC16IS752, SC16IS762. </p>
<p>This call must be make before any begin() calls. It will have no effect after begin(). </p>

</div>
</div>
<a id="a574613cfbf24c74bf9f85598843d38a3" name="a574613cfbf24c74bf9f85598843d38a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574613cfbf24c74bf9f85598843d38a3">&#9670;&#160;</a></span>withI2C()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp; SC16IS7xxInterface::withI2C </td>
          <td>(</td>
          <td class="paramtype">TwoWire *&#160;</td>
          <td class="paramname"><em>wire</em> = <code>&amp;Wire</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chip is connected by I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wire</td><td>The I2C port, typically &amp;Wire but could be &amp;Wire1, etc. Default is Wire (primary I2C on D0/D1). </td></tr>
    <tr><td class="paramname">addr</td><td>I2C address (see note below). Default is both 0x48, A0=HIGH, A1=HIGH. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_s_c16_i_s7xx_interface.html" title="Class that manages the SPI or I2C interface.">SC16IS7xxInterface</a>&amp;</dd></dl>
<p>A1 A0 Index I2C Address VDD VDD 0 0x48 VDD GND 1 0x49 VDD SCL 2 0x4a VDD SDA 3 0x4b GND VDD 4 0x4c GND GND 5 0x4d GND SCL 6 0x4e GND SDA 7 0x4f SCL VDD 8 0x50 SCL GND 9 0x51 SCL SCL 10 0x52 SCL SDA 11 0x53 SDA VDD 12 0x54 SDA GND 13 0x55 SDA SCL 14 0x56 SDA SDA 15 0x57</p>
<p>You can pass either the index (0 - 15) or the I2C address in the address field. Note that the NXP datasheet addresses must be divided by 2 because they include the R/W bit in the address, and Particle and Arduino do not. That's why the datasheet lists the starting address as 0x90 instead of 0x48.</p>
<p>The most common scenarios are both high (addr = 0x48 or 0x00) or both low (addr = 0x4d or 0x05)</p>
<p>Because of the way I2C works, the speed is selected per bus and not per I2C slave device like SPI. If all of your I2C devices work at 400 kHz, using <code>Wire.setSpeed(CLOCK_SPEED_400KHZ)</code> is recommended for better performance.</p>
<p>This call must be make before any begin() calls. It will have no effect after begin(). </p>

</div>
</div>
<a id="acc1d16a1d128fb558600b7bd0f63c859" name="acc1d16a1d128fb558600b7bd0f63c859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1d16a1d128fb558600b7bd0f63c859">&#9670;&#160;</a></span>withIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp; SC16IS7xxInterface::withIRQ </td>
          <td>(</td>
          <td class="paramtype">pin_t&#160;</td>
          <td class="paramname"><em>irqPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>INPUT_PULLUP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pin used for IRQ (hardware interrupts). This is optional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irqPin</td><td>Pin to use (D3, D4, ...) </td></tr>
    <tr><td class="paramname">mode</td><td>The pin mode. Default is INPUT_PULLUP. Could be INPUT instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_s_c16_i_s7xx_interface.html" title="Class that manages the SPI or I2C interface.">SC16IS7xxInterface</a>&amp;</dd></dl>
<p>This call must be make before any begin() calls. It will have no effect after begin(). </p>

</div>
</div>
<a id="a12feb9381bf52541d2ed613d3ea91f44" name="a12feb9381bf52541d2ed613d3ea91f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12feb9381bf52541d2ed613d3ea91f44">&#9670;&#160;</a></span>withOscillatorFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp; SC16IS7xxInterface::withOscillatorFrequency </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>freqHz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the oscillator frequency for the chip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freqHz</td><td>Typically 1843200 (default, 1.8432 MHz), or 3072000 (3.072 MHz). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>* <a class="el" href="class_s_c16_i_s7xx_interface.html" title="Class that manages the SPI or I2C interface.">SC16IS7xxInterface</a>&amp;</dd></dl>
<p>This call must be make before any begin() calls. It will have no effect after begin(). </p>

</div>
</div>
<a id="a6d7cdbe45c679802002e0e99c2fda566" name="a6d7cdbe45c679802002e0e99c2fda566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7cdbe45c679802002e0e99c2fda566">&#9670;&#160;</a></span>withSPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c16_i_s7xx_interface.html">SC16IS7xxInterface</a> &amp; SC16IS7xxInterface::withSPI </td>
          <td>(</td>
          <td class="paramtype">SPIClass *&#160;</td>
          <td class="paramname"><em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pin_t&#160;</td>
          <td class="paramname"><em>csPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>speedMHz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chip is connected by SPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi</td><td>The SPI port. Typically &amp;SPI but could be &amp;SPI1, etc. </td></tr>
    <tr><td class="paramname">csPin</td><td>The pin used for chip select </td></tr>
    <tr><td class="paramname">speedMHz</td><td>The SPI bus speed in MHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_s_c16_i_s7xx_interface.html" title="Class that manages the SPI or I2C interface.">SC16IS7xxInterface</a>&amp;</dd></dl>
<p>This call must be make before any begin() calls. It will have no effect after begin(). </p>

</div>
</div>
<a id="a85acd16652a58430558cd180856e47d9" name="a85acd16652a58430558cd180856e47d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85acd16652a58430558cd180856e47d9">&#9670;&#160;</a></span>writeInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SC16IS7xxInterface::writeInternal </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to write data. </p>
<p>It can only write 31 bytes at a time, the maximum that will fit in a 32 byte I2C transaction with the register address in the first byte. </p>

</div>
</div>
<a id="a298db59f1ca271b430fbb37e082ecf0b" name="a298db59f1ca271b430fbb37e082ecf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298db59f1ca271b430fbb37e082ecf0b">&#9670;&#160;</a></span>writeRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SC16IS7xxInterface::writeRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel (0-3).</td></tr>
    <tr><td class="paramname">reg</td><td>The register number to write. Note that this should be the register 0 - 16, before shifting for channel.</td></tr>
    <tr><td class="paramname">value</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_s_c16_i_s7xx_r_k_8h_source.html">SC16IS7xxRK.h</a></li>
<li>src/SC16IS7xxRK.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
