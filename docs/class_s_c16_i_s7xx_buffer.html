<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SC16IS7xxRK: SC16IS7xxBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SC16IS7xxRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">SC16IS7xxBuffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class used internally for buffering data.  
 <a href="class_s_c16_i_s7xx_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_c16_i_s7xx_r_k_8h_source.html">SC16IS7xxRK.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a9589d3e0f05fcb140f6ce04c46a2cc"><td class="memItemLeft" align="right" valign="top"><a id="a5a9589d3e0f05fcb140f6ce04c46a2cc" name="a5a9589d3e0f05fcb140f6ce04c46a2cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SC16IS7xxBuffer</b> ()</td></tr>
<tr class="memdesc:a5a9589d3e0f05fcb140f6ce04c46a2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a buffer object. You will normally never have to instantiate one. <br /></td></tr>
<tr class="separator:a5a9589d3e0f05fcb140f6ce04c46a2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413d16acfae3880e3fd7464f2e070609"><td class="memItemLeft" align="right" valign="top"><a id="a413d16acfae3880e3fd7464f2e070609" name="a413d16acfae3880e3fd7464f2e070609"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~SC16IS7xxBuffer</b> ()</td></tr>
<tr class="memdesc:a413d16acfae3880e3fd7464f2e070609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. You should never need to delete one. <br /></td></tr>
<tr class="separator:a413d16acfae3880e3fd7464f2e070609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e9e259320fe85344ddbacca4494ae4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#ad1e9e259320fe85344ddbacca4494ae4">init</a> (size_t <a class="el" href="class_s_c16_i_s7xx_buffer.html#a0864de3d46edb3bdb20e4a466ccf57dc">bufSize</a>)</td></tr>
<tr class="memdesc:ad1e9e259320fe85344ddbacca4494ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the buffer.  <br /></td></tr>
<tr class="separator:ad1e9e259320fe85344ddbacca4494ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948c75f0a18ee760dbca4189f6bb5ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#a7948c75f0a18ee760dbca4189f6bb5ad">availableToRead</a> () const</td></tr>
<tr class="memdesc:a7948c75f0a18ee760dbca4189f6bb5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that can be read from the buffer.  <br /></td></tr>
<tr class="separator:a7948c75f0a18ee760dbca4189f6bb5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011d8d2320d77791d94e8ea3ef7dfcf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#a011d8d2320d77791d94e8ea3ef7dfcf7">read</a> ()</td></tr>
<tr class="memdesc:a011d8d2320d77791d94e8ea3ef7dfcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte.  <br /></td></tr>
<tr class="separator:a011d8d2320d77791d94e8ea3ef7dfcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba92874f925dd8f1491663d1aad4fa97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#aba92874f925dd8f1491663d1aad4fa97">read</a> (uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:aba92874f925dd8f1491663d1aad4fa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes of data to a buffer.  <br /></td></tr>
<tr class="separator:aba92874f925dd8f1491663d1aad4fa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3198cee7f8f39841af2c56c16201368c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#a3198cee7f8f39841af2c56c16201368c">availableToWrite</a> () const</td></tr>
<tr class="memdesc:a3198cee7f8f39841af2c56c16201368c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes available to write into the buffer.  <br /></td></tr>
<tr class="separator:a3198cee7f8f39841af2c56c16201368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18853567762d55c07a93833d1cc5367"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#ae18853567762d55c07a93833d1cc5367">write</a> (const uint8_t *buffer, size_t size)</td></tr>
<tr class="memdesc:ae18853567762d55c07a93833d1cc5367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the buffer.  <br /></td></tr>
<tr class="separator:ae18853567762d55c07a93833d1cc5367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8c33fcc36ee04c6ea15b841f50353e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#a9e8c33fcc36ee04c6ea15b841f50353e">writeCallback</a> (std::function&lt; void(uint8_t *buffer, size_t &amp;size)&gt; callback)</td></tr>
<tr class="memdesc:a9e8c33fcc36ee04c6ea15b841f50353e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into buffer using a non-copy callback.  <br /></td></tr>
<tr class="separator:a9e8c33fcc36ee04c6ea15b841f50353e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d880a9c919dd77af82ecd339b65231"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#a88d880a9c919dd77af82ecd339b65231">lock</a> () const</td></tr>
<tr class="memdesc:a88d880a9c919dd77af82ecd339b65231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the buffer mutex.  <br /></td></tr>
<tr class="separator:a88d880a9c919dd77af82ecd339b65231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca94d28e65e03551a50b9e692b040664"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#aca94d28e65e03551a50b9e692b040664">trylock</a> () const</td></tr>
<tr class="memdesc:aca94d28e65e03551a50b9e692b040664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to lock the mutex. If already locked from another thread, returns false.  <br /></td></tr>
<tr class="separator:aca94d28e65e03551a50b9e692b040664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2b10048230160cfba267c3a0198176"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c16_i_s7xx_buffer.html#a1c2b10048230160cfba267c3a0198176">try_lock</a> () const</td></tr>
<tr class="memdesc:a1c2b10048230160cfba267c3a0198176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to lock the mutex. If already locked from another thread, returns false.  <br /></td></tr>
<tr class="separator:a1c2b10048230160cfba267c3a0198176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d70356b887b14f2bdc279768b9213e"><td class="memItemLeft" align="right" valign="top"><a id="af5d70356b887b14f2bdc279768b9213e" name="af5d70356b887b14f2bdc279768b9213e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock</b> () const</td></tr>
<tr class="memdesc:af5d70356b887b14f2bdc279768b9213e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the buffer mutex. <br /></td></tr>
<tr class="separator:af5d70356b887b14f2bdc279768b9213e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2e42c51c8edc95b0d2658561f33f4b28"><td class="memItemLeft" align="right" valign="top"><a id="a2e42c51c8edc95b0d2658561f33f4b28" name="a2e42c51c8edc95b0d2658561f33f4b28"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SC16IS7xxBuffer</b> (const <a class="el" href="class_s_c16_i_s7xx_buffer.html">SC16IS7xxBuffer</a> &amp;)=delete</td></tr>
<tr class="memdesc:a2e42c51c8edc95b0d2658561f33f4b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a2e42c51c8edc95b0d2658561f33f4b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b19927efa0845ec86d71dc5e18c7c93"><td class="memItemLeft" align="right" valign="top"><a id="a4b19927efa0845ec86d71dc5e18c7c93" name="a4b19927efa0845ec86d71dc5e18c7c93"></a>
<a class="el" href="class_s_c16_i_s7xx_buffer.html">SC16IS7xxBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_s_c16_i_s7xx_buffer.html">SC16IS7xxBuffer</a> &amp;)=delete</td></tr>
<tr class="memdesc:a4b19927efa0845ec86d71dc5e18c7c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a4b19927efa0845ec86d71dc5e18c7c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8c13e489e6a49211546967b5b3050a"><td class="memItemLeft" align="right" valign="top"><a id="ada8c13e489e6a49211546967b5b3050a" name="ada8c13e489e6a49211546967b5b3050a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free</b> ()</td></tr>
<tr class="memdesc:ada8c13e489e6a49211546967b5b3050a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the allocate buffer buf - used internally. <br /></td></tr>
<tr class="separator:ada8c13e489e6a49211546967b5b3050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad95c43f8da8d6e19a5f21e9396a46a75"><td class="memItemLeft" align="right" valign="top"><a id="ad95c43f8da8d6e19a5f21e9396a46a75" name="ad95c43f8da8d6e19a5f21e9396a46a75"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>buf</b> = nullptr</td></tr>
<tr class="memdesc:ad95c43f8da8d6e19a5f21e9396a46a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer, allocated on heap. <br /></td></tr>
<tr class="separator:ad95c43f8da8d6e19a5f21e9396a46a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0864de3d46edb3bdb20e4a466ccf57dc"><td class="memItemLeft" align="right" valign="top"><a id="a0864de3d46edb3bdb20e4a466ccf57dc" name="a0864de3d46edb3bdb20e4a466ccf57dc"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bufSize</b> = 0</td></tr>
<tr class="memdesc:a0864de3d46edb3bdb20e4a466ccf57dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of buffer in bytes. <br /></td></tr>
<tr class="separator:a0864de3d46edb3bdb20e4a466ccf57dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9842d747767fe054960dcd69a948ce3"><td class="memItemLeft" align="right" valign="top"><a id="ac9842d747767fe054960dcd69a948ce3" name="ac9842d747767fe054960dcd69a948ce3"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>readOffset</b> = 0</td></tr>
<tr class="memdesc:ac9842d747767fe054960dcd69a948ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where to read from next, may be larger than bufSize. <br /></td></tr>
<tr class="separator:ac9842d747767fe054960dcd69a948ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7711f2a0ce479fefc865678eaf7fd6f2"><td class="memItemLeft" align="right" valign="top"><a id="a7711f2a0ce479fefc865678eaf7fd6f2" name="a7711f2a0ce479fefc865678eaf7fd6f2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>writeOffset</b> = 0</td></tr>
<tr class="memdesc:a7711f2a0ce479fefc865678eaf7fd6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where to write to next, may be larger than bufSize. <br /></td></tr>
<tr class="separator:a7711f2a0ce479fefc865678eaf7fd6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906a0e05d7476612df67450f2becde29"><td class="memItemLeft" align="right" valign="top"><a id="a906a0e05d7476612df67450f2becde29" name="a906a0e05d7476612df67450f2becde29"></a>
RecursiveMutex&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b></td></tr>
<tr class="memdesc:a906a0e05d7476612df67450f2becde29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to use to access buf, readOffset, or writeOffset. <br /></td></tr>
<tr class="separator:a906a0e05d7476612df67450f2becde29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class used internally for buffering data. </p>
<p>Since the hardware FIFO is only 64 bytes, this class is used to store data in a larger buffer allocated on the heap.</p>
<p>You do not create one of these objects; it's created automatically when using withBufferedRead(). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7948c75f0a18ee760dbca4189f6bb5ad" name="a7948c75f0a18ee760dbca4189f6bb5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7948c75f0a18ee760dbca4189f6bb5ad">&#9670;&#160;</a></span>availableToRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SC16IS7xxBuffer::availableToRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of bytes that can be read from the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t Number of bytes that can be read. 0 = no data can be read now </dd></dl>

</div>
</div>
<a id="a3198cee7f8f39841af2c56c16201368c" name="a3198cee7f8f39841af2c56c16201368c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3198cee7f8f39841af2c56c16201368c">&#9670;&#160;</a></span>availableToWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SC16IS7xxBuffer::availableToWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of bytes available to write into the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t Number of bytes that can be written </dd></dl>

</div>
</div>
<a id="ad1e9e259320fe85344ddbacca4494ae4" name="ad1e9e259320fe85344ddbacca4494ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e9e259320fe85344ddbacca4494ae4">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SC16IS7xxBuffer::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufSize</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The buffer was allocated </dd>
<dd>
false The buffer could not be allocated, typically out of heap space, or no contiguous block available</dd></dl>
<p>This is called from withBufferedRead(), </p>

</div>
</div>
<a id="a88d880a9c919dd77af82ecd339b65231" name="a88d880a9c919dd77af82ecd339b65231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d880a9c919dd77af82ecd339b65231">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SC16IS7xxBuffer::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the buffer mutex. </p>
<p>A recursive mutex is used to protect access to buf, readOffset, and writeOffset since they can be accessed from two different threads. The buffer is written from the worker thread and read from whatever thread the user is reading from, typically the application loop thread. </p>

</div>
</div>
<a id="a011d8d2320d77791d94e8ea3ef7dfcf7" name="a011d8d2320d77791d94e8ea3ef7dfcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011d8d2320d77791d94e8ea3ef7dfcf7">&#9670;&#160;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SC16IS7xxBuffer::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single byte. </p>
<dl class="section return"><dt>Returns</dt><dd>int The byte value (0 - 255) or -1 if there is no data available to read. </dd></dl>

</div>
</div>
<a id="aba92874f925dd8f1491663d1aad4fa97" name="aba92874f925dd8f1491663d1aad4fa97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba92874f925dd8f1491663d1aad4fa97">&#9670;&#160;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SC16IS7xxBuffer::read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes of data to a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store data into </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The number of bytes actually read.</dd></dl>
<p>The <a class="el" href="class_s_c16_i_s7xx_buffer.html#a011d8d2320d77791d94e8ea3ef7dfcf7" title="Read a single byte.">read()</a> call does not block. It will only return the number of bytes currently available to read, so the number of bytes read will often be smaller than the requested number of bytes in size. The returned data is not null terminated. </p>

</div>
</div>
<a id="a1c2b10048230160cfba267c3a0198176" name="a1c2b10048230160cfba267c3a0198176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2b10048230160cfba267c3a0198176">&#9670;&#160;</a></span>try_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SC16IS7xxBuffer::try_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to lock the mutex. If already locked from another thread, returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="aca94d28e65e03551a50b9e692b040664" name="aca94d28e65e03551a50b9e692b040664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca94d28e65e03551a50b9e692b040664">&#9670;&#160;</a></span>trylock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SC16IS7xxBuffer::trylock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to lock the mutex. If already locked from another thread, returns false. </p>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="ae18853567762d55c07a93833d1cc5367" name="ae18853567762d55c07a93833d1cc5367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18853567762d55c07a93833d1cc5367">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SC16IS7xxBuffer::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramname">size</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes written</dd></dl>
<p>This call does not block until there is space in the buffer! If there is insufficient space, only the bytes that will fit are stored and the return value indicates the amount the was stored. </p>

</div>
</div>
<a id="a9e8c33fcc36ee04c6ea15b841f50353e" name="a9e8c33fcc36ee04c6ea15b841f50353e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8c33fcc36ee04c6ea15b841f50353e">&#9670;&#160;</a></span>writeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SC16IS7xxBuffer::writeCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(uint8_t *buffer, size_t &amp;size)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data into buffer using a non-copy callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function or C++ lambda, see below</td></tr>
  </table>
  </dd>
</dl>
<p>This is used internally from the worker thread after reading a block of data from the UART by I2C or SPI. There is no single-byte write because that is never done because it would be extraordinarily inefficient.</p>
<p>Callback prototype: void(uint8_t *buffer, size_t &amp;size)</p>
<p>If there is room in the buffer to write data, your callback is called during the execution of writeCallback. It's passed a buffer you should write data to and a size which is the maximum number of bytes you can write. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_s_c16_i_s7xx_r_k_8h_source.html">SC16IS7xxRK.h</a></li>
<li>src/SC16IS7xxRK.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
